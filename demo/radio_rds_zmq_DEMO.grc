options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: Custom
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: top_block
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: ''
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 0.0]
    rotation: 0
    state: enabled

blocks:
- name: code
  id: variable_qtgui_chooser
  parameters:
    comment: ''
    gui_hint: ''
    label: ''
    label0: France bleu Alsace F405
    label1: France Musique F203
    label2: France Inter F201
    label3: France Inter 2 F201
    label4: ''
    labels: '[]'
    num_opts: '3'
    option0: '01100110100101010101010101101001'
    option1: '01100110101001010101010101011001'
    option2: '01100110101001010101010101010110'
    option3: '00110011010100101010101010101011'
    option4: France Info
    options: '[0, 1, 2]'
    orient: Qt.QVBoxLayout
    type: string
    value: '01100110101001010101010101010110'
    widget: radio_buttons
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1512, 12.0]
    rotation: 0
    state: true
- name: fichier
  id: variable_qtgui_chooser
  parameters:
    comment: ''
    gui_hint: ''
    label: ''
    label0: 'France bleu Alsace '
    label1: France Musique
    label2: France Inter
    label3: France Inter 2
    label4: ''
    labels: '[]'
    num_opts: '4'
    option0: FranceBleu102_6_21janv2017.dat
    option1: FranceMusique91_6_21janv2017.dat
    option2: FranceInter95_7_21janv2017.dat
    option3: FranceInterALT95_7_21janv2017.dat
    option4: '4'
    options: '[0, 1, 2]'
    orient: Qt.QVBoxLayout
    type: string
    value: FranceInterALT95_7_21janv2017.dat
    widget: radio_buttons
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1520, 228.0]
    rotation: 0
    state: true
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: 2.1168e6
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [168, 5]
    rotation: 0
    state: enabled
- name: analog_agc_xx_0
  id: analog_agc_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    gain: '1.0'
    max_gain: '65536'
    maxoutbuf: '0'
    minoutbuf: '0'
    rate: 1e-4
    reference: '1'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [856, 192.0]
    rotation: 0
    state: enabled
- name: analog_wfm_rcv_0_0
  id: analog_wfm_rcv
  parameters:
    affinity: ''
    alias: ''
    audio_decimation: '4'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    quad_rate: samp_rate
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [368, 112.0]
    rotation: 0
    state: enabled
- name: audio_sink_0
  id: audio_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    device_name: ''
    num_inputs: '1'
    ok_to_block: 'True'
    samp_rate: '44100'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [872, 96.0]
    rotation: 0
    state: enabled
- name: blocks_complex_to_arg_0_0_0
  id: blocks_complex_to_arg
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [704, 360.0]
    rotation: 180
    state: enabled
- name: blocks_complex_to_real_0
  id: blocks_complex_to_real
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1320, 192.0]
    rotation: 0
    state: enabled
- name: blocks_file_source_0
  id: blocks_file_source
  parameters:
    affinity: ''
    alias: ''
    begin_tag: pmt.PMT_NIL
    comment: ''
    file: fichier
    length: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    offset: '0'
    repeat: 'True'
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 88.0]
    rotation: 0
    state: enabled
- name: blocks_float_to_uchar_0
  id: blocks_float_to_uchar
  parameters:
    affinity: ''
    alias: ''
    bias: '0'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [360, 344.0]
    rotation: 180
    state: enabled
- name: blocks_threshold_ff_0
  id: blocks_threshold_ff
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    high: '0'
    init: '0'
    low: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [544, 336.0]
    rotation: 180
    state: enabled
- name: blocks_throttle2_0
  id: blocks_throttle2
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    ignoretag: 'True'
    limit: auto
    maximum: '0.1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samples_per_second: samp_rate
    type: complex
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [168, 112.0]
    rotation: 0
    state: enabled
- name: digital_correlate_access_code_tag_xx_0
  id: digital_correlate_access_code_tag_xx
  parameters:
    access_code: code
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: packet
    threshold: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [104, 456.0]
    rotation: 0
    state: enabled
- name: digital_correlate_access_code_tag_xx_0_0
  id: digital_correlate_access_code_tag_xx
  parameters:
    access_code: '''''.join(str(1 - int(elts)) for elts in code)'
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tagname: packet
    threshold: '0'
    type: byte
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [104, 336.0]
    rotation: 180
    state: enabled
- name: digital_costas_loop_cc_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '4'
    use_snr: 'False'
    w: 20e-3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1064, 192.0]
    rotation: 0
    state: enabled
- name: digital_symbol_sync_xx_0
  id: digital_symbol_sync_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: digital.constellation_bpsk().base()
    damping: '1.0'
    loop_bw: '0.045'
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    nfilters: '128'
    osps: '1'
    pfb_mf_taps: '[]'
    resamp_type: digital.IR_MMSE_8TAP
    sps: samp_rate/2/40/(1187.5*2)
    ted_gain: '1.0'
    ted_type: digital.TED_MUELLER_AND_MULLER
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1008, 364.0]
    rotation: 180
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\nimport\
      \ binascii\nimport time\nimport json\nimport zmq\n\nclass blk(gr.basic_block):\n\
      \    def __init__(self, tag_name=\"packet\", zmq_addr=\"tcp://127.0.0.1:5556\"\
      , print_verbose=\"YES\"):\n        gr.basic_block.__init__(\n            self,\n\
      \            name='RDS decoder',\n            in_sig=[np.uint8],\n         \
      \   out_sig=[]\n        )\n\n        self.tag_name = tag_name\n        self.max_block_length\
      \ = 156\n\n        self.print_verbose = (str(print_verbose).upper() == \"YES\"\
      )\n\n        self.nom = [' ',' ',' ',' ',' ',' ',' ',' ']\n        self.texte\
      \ = ['  '] * 65\n\n        self.capture = False\n        self.byte = []\n  \
      \      self.start_abs = 0\n\n        self.zmq_addr = zmq_addr\n        self.zctx\
      \ = zmq.Context.instance()\n        self.zpub = self.zctx.socket(zmq.PUB)\n\
      \        self.zpub.bind(self.zmq_addr)\n\n        self.last_ps = \"\"\n    \
      \    self.last_rt = \"\"\n        self.last_send = 0.0\n\n    def general_work(self,\
      \ input_items, output_items):\n        in0 = input_items[0]\n        ninput\
      \ = len(in0)\n        abs0 = int(self.nitems_read(0))\n        j0 = 0\n\n  \
      \      if self.capture == False:\n            tags = self.get_tags_in_window(0,\
      \ 0, ninput)\n            for tg in tags:\n                if tg.key == pmt.intern(self.tag_name):\n\
      \                    self.start_abs = int(tg.offset)\n                    j0\
      \ = self.start_abs - abs0\n                    if j0 < 0:\n                \
      \        j0 = 0\n                    self.capture = True\n                 \
      \   self.byte = []\n                    break\n\n        if self.capture ==\
      \ True:\n            j = j0\n            while j < ninput and len(self.byte)\
      \ < self.max_block_length:\n                self.byte.append(str(int(in0[j])))\n\
      \                j += 1\n\n            if len(self.byte) >= self.max_block_length:\n\
      \                trame_dec = \"0\"\n                i = 1\n                while\
      \ i <= len(self.byte) - 2:\n                    if (self.byte[i] != self.byte[i+1]):\n\
      \                        trame_dec += '0'\n                    else:\n     \
      \                   trame_dec += '1'\n                    i = i + 2\n\n    \
      \            ps = ''.join(self.nom)\n                rt = ''.join(self.texte[0:64])\n\
      \n                if len(trame_dec) >= 78:\n                    if trame_dec[10:15]\
      \ == '00000':\n                        v1 = int(trame_dec[62:70], 2)\n     \
      \                   v2 = int(trame_dec[70:78], 2)\n\n                      \
      \  char_dec  = bytes([v1]).decode('latin-1', errors='replace')\n           \
      \             char_dec2 = bytes([v2]).decode('latin-1', errors='replace')\n\n\
      \                        if trame_dec[24:26] == '00':\n                    \
      \        self.nom[0] = char_dec\n                            self.nom[1] = char_dec2\n\
      \                        if trame_dec[24:26] == '01':\n                    \
      \        self.nom[2] = char_dec\n                            self.nom[3] = char_dec2\n\
      \                        if trame_dec[24:26] == '10':\n                    \
      \        self.nom[4] = char_dec\n                            self.nom[5] = char_dec2\n\
      \                        if trame_dec[24:26] == '11':\n                    \
      \        self.nom[6] = char_dec\n                            self.nom[7] = char_dec2\n\
      \n                        ps = ''.join(self.nom)\n                        if\
      \ self.print_verbose:\n                            print(ps, flush=True)\n\n\
      \                    if trame_dec[10:15] == '00100':\n                     \
      \   A = bytes([int(trame_dec[36:44],2)]).decode('latin-1', errors='replace')\n\
      \                        B = bytes([int(trame_dec[44:52],2)]).decode('latin-1',\
      \ errors='replace')\n                        C = bytes([int(trame_dec[62:70],2)]).decode('latin-1',\
      \ errors='replace')\n                        D = bytes([int(trame_dec[70:78],2)]).decode('latin-1',\
      \ errors='replace')\n\n                        indice = (int(trame_dec[22])*8\
      \ + int(trame_dec[23])*4 + int(trame_dec[24])*2 + int(trame_dec[25])) * 4\n\
      \                        if 0 <= indice <= 60:\n                           \
      \ self.texte[indice+0] = A\n                            self.texte[indice+1]\
      \ = B\n                            self.texte[indice+2] = C\n              \
      \              self.texte[indice+3] = D\n\n                        rt = ''.join(self.texte[0:64])\n\
      \                        if self.print_verbose:\n                          \
      \  print(rt, flush=True)\n\n                t = time.time()\n              \
      \  if (ps != self.last_ps) or (rt != self.last_rt) or (t - self.last_send >\
      \ 0.25):\n                    msg = {\"ps\": ps, \"rt\": rt, \"t\": t}\n   \
      \                 try:\n                        self.zpub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                    except zmq.Again:\n              \
      \          pass\n                    self.last_ps = ps\n                   \
      \ self.last_rt = rt\n                    self.last_send = t\n\n            \
      \    self.capture = False\n                self.byte = []\n\n        self.consume(0,\
      \ ninput)\n        return 0\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    print_verbose: '''YES'''
    tag_name: '''packet'''
    zmq_addr: '"tcp://127.0.0.1:5556"'
  states:
    _io_cache: ('RDS decoder', 'blk', [('tag_name', "'packet'"), ('zmq_addr', "'tcp://127.0.0.1:5556'"),
      ('print_verbose', "'YES'")], [('0', 'byte', 1)], [], '', ['print_verbose', 'tag_name',
      'zmq_addr'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [376, 464.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport time, json\n\
      import zmq\n\nclass blk(gr.sync_block):\n    def __init__(self, zmq_addr=\"\
      tcp://127.0.0.1:5557\", target_pts=1200, publish_hz=20):\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"audio_scope_zmq\",\n            in_sig=[np.float32],\n\
      \            out_sig=[]\n        )\n        self.zmq_addr = zmq_addr\n     \
      \   self.target_pts = int(target_pts)\n        self.publish_period = 1.0 / float(publish_hz)\n\
      \n        self.ctx = zmq.Context.instance()\n        self.pub = self.ctx.socket(zmq.PUB)\n\
      \        self.pub.bind(self.zmq_addr)\n\n        self.buf = np.zeros(0, dtype=np.float32)\n\
      \        self.last_pub = 0.0\n\n    def work(self, input_items, output_items):\n\
      \        x = input_items[0]\n        if x.size == 0:\n            return 0\n\
      \n        # accumulate\n        self.buf = np.concatenate([self.buf, x.astype(np.float32,\
      \ copy=False)])\n\n        now = time.time()\n        if (now - self.last_pub)\
      \ >= self.publish_period:\n            # on veut envoyer ~target_pts points,\
      \ d\xE9cim\xE9s depuis le buffer r\xE9cent\n            # on prend une fen\xEA\
      tre assez grande (ex: dernier 0.2 s si possible)\n            # et on sous-\xE9\
      chantillonne pour tomber sur target_pts\n            n = self.buf.size\n   \
      \         if n > 0:\n                # garde seulement les derniers \xE9chantillons\
      \ (limite m\xE9moire)\n                max_keep = 44100  # 1 s @ 44.1k (tu peux\
      \ ajuster)\n                if n > max_keep:\n                    self.buf =\
      \ self.buf[-max_keep:]\n                    n = self.buf.size\n\n          \
      \      # sous-\xE9chantillonnage simple\n                if n >= self.target_pts:\n\
      \                    step = max(1, n // self.target_pts)\n                 \
      \   y = self.buf[::step][:self.target_pts]\n                else:\n        \
      \            y = self.buf  # pas assez, envoie ce qu\u2019on a\n\n         \
      \       # petite normalisation d\u2019affichage (pas obligatoire)\n        \
      \        peak = float(np.max(np.abs(y))) if y.size else 0.0\n              \
      \  rms = float(np.sqrt(np.mean(y*y))) if y.size else 0.0\n\n               \
      \ msg = {\n                    \"t\": now,\n                    \"sr\": 44100,\
      \              # info indicative\n                    \"peak\": peak,\n    \
      \                \"rms\": rms,\n                    \"y\": y.tolist()\n    \
      \            }\n                try:\n                    self.pub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                except Exception:\n                  \
      \  pass\n\n                self.last_pub = now\n\n        return len(x)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    publish_hz: '5'
    target_pts: '400'
    zmq_addr: '"tcp://127.0.0.1:5557"'
  states:
    _io_cache: ('audio_scope_zmq', 'blk', [('zmq_addr', "'tcp://127.0.0.1:5557'"),
      ('target_pts', '1200'), ('publish_hz', '20')], [('0', 'float', 1)], [], '',
      ['target_pts', 'zmq_addr'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [864, 0.0]
    rotation: 0
    state: enabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport time, json\n\
      import zmq\n\nclass blk(gr.sync_block):\n    def __init__(self, zmq_addr=\"\
      tcp://127.0.0.1:5558\",\n                 in_rate=1058400.0, target_pts=1400,\
      \ publish_hz=15,\n                 window_ms=6.0):\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"rds_scope_zmq\",\n            in_sig=[np.float32],\n\
      \            out_sig=[]\n        )\n        self.zmq_addr = zmq_addr\n     \
      \   self.in_rate = float(in_rate)\n        self.target_pts = int(target_pts)\n\
      \        self.publish_period = 1.0 / float(publish_hz)\n        self.window_ms\
      \ = float(window_ms)\n\n        self.ctx = zmq.Context.instance()\n        self.pub\
      \ = self.ctx.socket(zmq.PUB)\n        self.pub.bind(self.zmq_addr)\n\n     \
      \   self.buf = np.zeros(0, dtype=np.float32)\n        self.last_pub = 0.0\n\n\
      \        # buffer de s\xE9curit\xE9 (on garde large)\n        self.max_keep\
      \ = int(self.in_rate * 0.10)  # 100 ms\n\n    def work(self, input_items, output_items):\n\
      \        x = input_items[0]\n        if x.size == 0:\n            return 0\n\
      \n        # accumulate\n        self.buf = np.concatenate([self.buf, x.astype(np.float32,\
      \ copy=False)])\n        if self.buf.size > self.max_keep:\n            self.buf\
      \ = self.buf[-self.max_keep:]\n\n        now = time.time()\n        if (now\
      \ - self.last_pub) >= self.publish_period:\n            n = self.buf.size\n\
      \            if n > 16:\n                # ---- fen\xEAtre TEMPS impos\xE9e\
      \ ----\n                win_n = int(self.in_rate * (self.window_ms / 1000.0))\n\
      \                win_n = max(32, min(win_n, n))  # bornes\n                w\
      \ = self.buf[-win_n:]          # segment contigu\n\n                # ---- d\xE9\
      cimation d'affichage dans la fen\xEAtre ----\n                step = max(1,\
      \ win_n // self.target_pts)\n                y = w[::step][:self.target_pts]\n\
      \n                peak = float(np.max(np.abs(y))) if y.size else 0.0\n     \
      \           rms = float(np.sqrt(np.mean(y*y))) if y.size else 0.0\n\n      \
      \          msg = {\n                    \"t\": now,\n                    \"\
      sr\": self.in_rate / step,   # \"sr affich\xE9\" coh\xE9rent\n             \
      \       \"peak\": peak,\n                    \"rms\": rms,\n               \
      \     \"y\": y.tolist(),\n                    \"window_ms\": self.window_ms\n\
      \                }\n                try:\n                    self.pub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                except Exception:\n                  \
      \  pass\n\n                self.last_pub = now\n\n        return len(x)\n"
    affinity: ''
    alias: ''
    comment: ''
    in_rate: samp_rate/2/40
    maxoutbuf: '0'
    minoutbuf: '0'
    publish_hz: '5'
    target_pts: '400'
    window_ms: '12'
    zmq_addr: '"tcp://127.0.0.1:5558"'
  states:
    _io_cache: ('rds_scope_zmq', 'blk', [('zmq_addr', "'tcp://127.0.0.1:5558'"), ('in_rate',
      '1058400.0'), ('target_pts', '1400'), ('publish_hz', '15'), ('window_ms', '6.0')],
      [('0', 'float', 1)], [], '', ['in_rate', 'target_pts', 'window_ms', 'zmq_addr'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1312, 256.0]
    rotation: 180
    state: enabled
- name: epy_block_3
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport time, json\n\
      import zmq\n\nclass blk(gr.sync_block):\n    \"\"\"\n    Constellation scope\
      \ web : publie un nuage I/Q (complex64) via ZMQ JSON.\n    Entr\xE9e : complex64\n\
      \    Sortie : aucune\n    \"\"\"\n    def __init__(self,\n                 zmq_addr=\"\
      tcp://127.0.0.1:5559\",\n                 points=1200,\n                 publish_hz=10,\n\
      \                 decim=1):\n        gr.sync_block.__init__(\n            self,\n\
      \            name=\"constellation_scope_zmq\",\n            in_sig=[np.complex64],\n\
      \            out_sig=[]\n        )\n        self.zmq_addr = zmq_addr\n     \
      \   self.points = int(points)\n        self.publish_period = 1.0 / float(publish_hz)\n\
      \        self.decim = max(1, int(decim))\n\n        self.ctx = zmq.Context.instance()\n\
      \        self.pub = self.ctx.socket(zmq.PUB)\n        self.pub.bind(self.zmq_addr)\n\
      \n        self.buf = np.zeros(0, dtype=np.complex64)\n        self.last_pub\
      \ = 0.0\n        self.max_keep = self.points * self.decim * 4  # marge\n\n \
      \   def work(self, input_items, output_items):\n        x = input_items[0]\n\
      \        if x.size == 0:\n            return 0\n\n        # d\xE9cimation l\xE9\
      g\xE8re pour limiter la charge\n        if self.decim > 1:\n            x =\
      \ x[::self.decim]\n\n        self.buf = np.concatenate([self.buf, x.astype(np.complex64,\
      \ copy=False)])\n        if self.buf.size > self.max_keep:\n            self.buf\
      \ = self.buf[-self.max_keep:]\n\n        now = time.time()\n        if (now\
      \ - self.last_pub) >= self.publish_period:\n            n = self.buf.size\n\
      \            if n >= 16:\n                N = min(self.points, n)\n        \
      \        z = self.buf[-N:]\n\n                i = np.real(z).astype(np.float32)\n\
      \                q = np.imag(z).astype(np.float32)\n\n                msg =\
      \ {\n                    \"t\": now,\n                    \"n\": int(N),\n \
      \                   \"i\": i.tolist(),\n                    \"q\": q.tolist()\n\
      \                }\n                try:\n                    self.pub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                except Exception:\n                  \
      \  pass\n\n                self.last_pub = now\n\n        return len(input_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    decim: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    points: '600'
    publish_hz: '5'
    zmq_addr: '"tcp://127.0.0.1:5559"'
  states:
    _io_cache: "('constellation_scope_zmq', 'blk', [('zmq_addr', \"'tcp://127.0.0.1:5559'\"\
      ), ('points', '1200'), ('publish_hz', '10'), ('decim', '1')], [('0', 'complex',\
      \ 1)], [], '\\nConstellation scope web : publie un nuage I/Q (complex64) via\
      \ ZMQ JSON.\\nEntr\xE9e : complex64\\nSortie : aucune\\n', ['decim', 'points',\
      \ 'zmq_addr'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [656, 440.0]
    rotation: 180
    state: enabled
- name: freq_xlating_fir_filter_xxx_0
  id: freq_xlating_fir_filter_xxx
  parameters:
    affinity: ''
    alias: ''
    center_freq: '57000'
    comment: ''
    decim: '20'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate/4
    taps: firdes.low_pass(40,samp_rate/4,2500,1000)
    type: fcc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [608, 192.0]
    rotation: 0
    state: enabled
- name: low_pass_filter_0_1
  id: low_pass_filter
  parameters:
    affinity: ''
    alias: ''
    beta: '6.76'
    comment: ''
    cutoff_freq: 20e3
    decim: '12'
    gain: '1'
    interp: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate/4
    type: fir_filter_fff
    width: 10e3
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [608, 16.0]
    rotation: 0
    state: enabled
- name: xmlrpc_server_0
  id: xmlrpc_server
  parameters:
    addr: 127.0.0.1
    alias: ''
    comment: ''
    port: '8080'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [296, 8.0]
    rotation: 0
    state: enabled

connections:
- [analog_agc_xx_0, '0', digital_costas_loop_cc_0, '0']
- [analog_wfm_rcv_0_0, '0', freq_xlating_fir_filter_xxx_0, '0']
- [analog_wfm_rcv_0_0, '0', low_pass_filter_0_1, '0']
- [blocks_complex_to_arg_0_0_0, '0', blocks_threshold_ff_0, '0']
- [blocks_complex_to_real_0, '0', epy_block_2, '0']
- [blocks_file_source_0, '0', blocks_throttle2_0, '0']
- [blocks_float_to_uchar_0, '0', digital_correlate_access_code_tag_xx_0_0, '0']
- [blocks_threshold_ff_0, '0', blocks_float_to_uchar_0, '0']
- [blocks_throttle2_0, '0', analog_wfm_rcv_0_0, '0']
- [digital_correlate_access_code_tag_xx_0, '0', epy_block_0, '0']
- [digital_correlate_access_code_tag_xx_0_0, '0', digital_correlate_access_code_tag_xx_0,
  '0']
- [digital_costas_loop_cc_0, '0', blocks_complex_to_real_0, '0']
- [digital_costas_loop_cc_0, '0', digital_symbol_sync_xx_0, '0']
- [digital_symbol_sync_xx_0, '0', blocks_complex_to_arg_0_0_0, '0']
- [digital_symbol_sync_xx_0, '0', epy_block_3, '0']
- [freq_xlating_fir_filter_xxx_0, '0', analog_agc_xx_0, '0']
- [low_pass_filter_0_1, '0', audio_sink_0, '0']
- [low_pass_filter_0_1, '0', epy_block_1, '0']

metadata:
  file_format: 1
  grc_version: 3.10.12.0
