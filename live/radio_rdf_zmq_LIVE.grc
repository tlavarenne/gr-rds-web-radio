options:
  parameters:
    author: ''
    catch_exceptions: 'True'
    category: Custom
    cmake_opt: ''
    comment: ''
    copyright: ''
    description: ''
    gen_cmake: 'On'
    gen_linking: dynamic
    generate_options: qt_gui
    hier_block_src_path: '.:'
    id: top_block
    max_nouts: '0'
    output_language: python
    placement: (0,0)
    qt_qss_theme: ''
    realtime_scheduling: ''
    run: 'True'
    run_command: '{python} -u {filename}'
    run_options: prompt
    sizing_mode: fixed
    thread_safe_setters: ''
    title: ''
    window_size: (1000,1000)
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [8, 0.0]
    rotation: 0
    state: enabled

blocks:
- name: freq
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: ''
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '87'
    step: '.1'
    stop: '108'
    value: '87'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1528, 16.0]
    rotation: 0
    state: enabled
- name: gain
  id: variable_qtgui_range
  parameters:
    comment: ''
    gui_hint: ''
    label: ''
    min_len: '200'
    orient: QtCore.Qt.Horizontal
    rangeType: float
    start: '0'
    step: '1'
    stop: '45'
    value: '10'
    widget: counter_slider
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1408, 16.0]
    rotation: 0
    state: enabled
- name: samp_rate
  id: variable
  parameters:
    comment: ''
    value: 2.1168e6
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [168, 5]
    rotation: 0
    state: enabled
- name: analog_agc_xx_0
  id: analog_agc_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    gain: '1.0'
    max_gain: '65536'
    maxoutbuf: '0'
    minoutbuf: '0'
    rate: 4e-4
    reference: '1'
    type: complex
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [936, 200.0]
    rotation: 0
    state: enabled
- name: analog_wfm_rcv_0_0
  id: analog_wfm_rcv
  parameters:
    affinity: ''
    alias: ''
    audio_decimation: '4'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    quad_rate: samp_rate
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [368, 112.0]
    rotation: 0
    state: enabled
- name: audio_sink_0
  id: audio_sink
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    device_name: ''
    num_inputs: '1'
    ok_to_block: 'True'
    samp_rate: '44100'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [856, 96.0]
    rotation: 0
    state: enabled
- name: blocks_complex_to_arg_0_0_0
  id: blocks_complex_to_arg
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [704, 384.0]
    rotation: 180
    state: enabled
- name: blocks_complex_to_real_0
  id: blocks_complex_to_real
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1376.0, 440]
    rotation: 270
    state: enabled
- name: blocks_float_to_uchar_0
  id: blocks_float_to_uchar
  parameters:
    affinity: ''
    alias: ''
    bias: '0'
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    scale: '1'
    vlen: '1'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [360, 368.0]
    rotation: 180
    state: enabled
- name: blocks_threshold_ff_0
  id: blocks_threshold_ff
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    high: '0'
    init: '0'
    low: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [552, 360.0]
    rotation: 180
    state: enabled
- name: digital_costas_loop_cc_0
  id: digital_costas_loop_cc
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    order: '4'
    use_snr: 'False'
    w: 20e-3
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1160, 200.0]
    rotation: 0
    state: enabled
- name: digital_symbol_sync_xx_0
  id: digital_symbol_sync_xx
  parameters:
    affinity: ''
    alias: ''
    comment: ''
    constellation: digital.constellation_bpsk().base()
    damping: '1.0'
    loop_bw: '0.005'
    max_dev: '1.5'
    maxoutbuf: '0'
    minoutbuf: '0'
    nfilters: '128'
    osps: '1'
    pfb_mf_taps: '[]'
    resamp_type: digital.IR_MMSE_8TAP
    sps: samp_rate/2/40/(1187.5*2)
    ted_gain: '1.0'
    ted_type: digital.TED_EARLY_LATE
    type: cc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1088, 364.0]
    rotation: 180
    state: enabled
- name: epy_block_0
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport pmt\nimport\
      \ binascii\nimport time\nimport json\nimport zmq\n\n\nclass blk(gr.basic_block):\n\
      \    def __init__(self, tag_name=\"packet\",\n                 zmq_addr=\"tcp://127.0.0.1:5556\"\
      ,\n                 print_verbose=\"YES\"):\n\n        gr.basic_block.__init__(\n\
      \            self,\n            name='RDS decoder',\n            in_sig=[np.uint8],\n\
      \            out_sig=[]\n        )\n\n        self.tag_name = tag_name\n   \
      \     self.max_block_length = 156\n\n        self.print_verbose = (str(print_verbose).upper()\
      \ == \"YES\")\n\n        self.nom = [' ',' ',' ',' ',' ',' ',' ',' ']\n    \
      \    self.texte = ['  '] * 65\n\n        self.capture = False\n        self.byte\
      \ = []\n        self.start_abs = 0\n\n        self.zmq_addr = zmq_addr\n   \
      \     self.zctx = zmq.Context.instance()\n        self.zpub = self.zctx.socket(zmq.PUB)\n\
      \        self.zpub.bind(self.zmq_addr)\n\n        self.last_ps = \"\"\n    \
      \    self.last_rt = \"\"\n        self.last_send = 0.0\n\n    # ----------------------------\n\
      \    # Simple character filters\n    # ----------------------------\n    @staticmethod\n\
      \    def _ok_ps(v):\n        # PS is typically uppercase + digits + space\n\
      \        return (v == 0x20) or (0x30 <= v <= 0x39) or (0x41 <= v <= 0x5A)\n\n\
      \    @staticmethod\n    def _ok_rt(v):\n        # RT is \"free text\": allow\
      \ printable ASCII + Latin-1 accents\n        # (reject control chars)\n    \
      \    return (v == 0x20) or (0x21 <= v <= 0x7E) or (0xA0 <= v <= 0xFF)\n\n  \
      \  def general_work(self, input_items, output_items):\n        in0 = input_items[0]\n\
      \        ninput = len(in0)\n\n        abs0 = int(self.nitems_read(0))\n    \
      \    j0 = 0\n\n        if not self.capture:\n            tags = self.get_tags_in_window(0,\
      \ 0, ninput)\n            for tg in tags:\n                if tg.key == pmt.intern(self.tag_name):\n\
      \                    self.start_abs = int(tg.offset)\n                    j0\
      \ = self.start_abs - abs0\n                    if j0 < 0:\n                \
      \        j0 = 0\n                    self.capture = True\n                 \
      \   self.byte = []\n                    break\n\n        if self.capture:\n\
      \            j = j0\n            while j < ninput and len(self.byte) < self.max_block_length:\n\
      \                self.byte.append(str(int(in0[j])))\n                j += 1\n\
      \n            if len(self.byte) >= self.max_block_length:\n                trame_dec\
      \ = \"0\"\n                i = 1\n                while i <= len(self.byte)\
      \ - 2:\n                    trame_dec += '0' if (self.byte[i] != self.byte[i\
      \ + 1]) else '1'\n                    i += 2\n\n                ps = ''.join(self.nom)\n\
      \                rt = ''.join(self.texte[0:64])\n\n                if len(trame_dec)\
      \ >= 78:\n\n                    # ---- PS (group 0) ----\n                 \
      \   if trame_dec[10:15] == '00000':\n                        v1 = int(trame_dec[62:70],\
      \ 2)\n                        v2 = int(trame_dec[70:78], 2)\n\n            \
      \            # Drop update if chars look wrong\n                        if self._ok_ps(v1)\
      \ and self._ok_ps(v2):\n                            c1 = bytes([v1]).decode('latin-1',\
      \ errors='replace')\n                            c2 = bytes([v2]).decode('latin-1',\
      \ errors='replace')\n\n                            seg = trame_dec[24:26]\n\
      \                            if seg == '00':\n                             \
      \   self.nom[0], self.nom[1] = c1, c2\n                            if seg ==\
      \ '01':\n                                self.nom[2], self.nom[3] = c1, c2\n\
      \                            if seg == '10':\n                             \
      \   self.nom[4], self.nom[5] = c1, c2\n                            if seg ==\
      \ '11':\n                                self.nom[6], self.nom[7] = c1, c2\n\
      \n                            ps = ''.join(self.nom)\n                     \
      \       if self.print_verbose:\n                                print(ps, flush=True)\n\
      \n                    # ---- RT (group 2A) ----\n                    if trame_dec[10:15]\
      \ == '00100':\n                        vA = int(trame_dec[36:44], 2)\n     \
      \                   vB = int(trame_dec[44:52], 2)\n                        vC\
      \ = int(trame_dec[62:70], 2)\n                        vD = int(trame_dec[70:78],\
      \ 2)\n\n                        # Drop update if any char looks wrong\n    \
      \                    if self._ok_rt(vA) and self._ok_rt(vB) and self._ok_rt(vC)\
      \ and self._ok_rt(vD):\n                            A = bytes([vA]).decode('latin-1',\
      \ errors='replace')\n                            B = bytes([vB]).decode('latin-1',\
      \ errors='replace')\n                            C = bytes([vC]).decode('latin-1',\
      \ errors='replace')\n                            D = bytes([vD]).decode('latin-1',\
      \ errors='replace')\n\n                            indice = (\n            \
      \                    int(trame_dec[22]) * 8 +\n                            \
      \    int(trame_dec[23]) * 4 +\n                                int(trame_dec[24])\
      \ * 2 +\n                                int(trame_dec[25])\n              \
      \              ) * 4\n\n                            if 0 <= indice <= 60:\n\
      \                                self.texte[indice + 0] = A\n              \
      \                  self.texte[indice + 1] = B\n                            \
      \    self.texte[indice + 2] = C\n                                self.texte[indice\
      \ + 3] = D\n\n                            rt = ''.join(self.texte[0:64])\n \
      \                           if self.print_verbose:\n                       \
      \         print(rt, flush=True)\n\n                t = time.time()\n       \
      \         if (ps != self.last_ps) or (rt != self.last_rt) or (t - self.last_send\
      \ > 0.25):\n                    msg = {\"ps\": ps, \"rt\": rt, \"t\": t}\n \
      \                   try:\n                        self.zpub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                    except zmq.Again:\n              \
      \          pass\n\n                    self.last_ps = ps\n                 \
      \   self.last_rt = rt\n                    self.last_send = t\n\n          \
      \      self.capture = False\n                self.byte = []\n\n        self.consume(0,\
      \ ninput)\n        return 0\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    print_verbose: '''YES'''
    tag_name: '''packet'''
    zmq_addr: '''tcp://127.0.0.1:5556'''
  states:
    _io_cache: ('RDS decoder', 'blk', [('tag_name', "'packet'"), ('zmq_addr', "'tcp://127.0.0.1:5556'"),
      ('print_verbose', "'YES'")], [('0', 'byte', 1)], [], '', ['print_verbose', 'tag_name',
      'zmq_addr'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [736, 592.0]
    rotation: 0
    state: enabled
- name: epy_block_1
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport time, json\n\
      import zmq\n\nclass blk(gr.sync_block):\n    def __init__(self, zmq_addr=\"\
      tcp://127.0.0.1:5557\", target_pts=1200, publish_hz=20):\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"audio_scope_zmq\",\n            in_sig=[np.float32],\n\
      \            out_sig=[]\n        )\n        self.zmq_addr = zmq_addr\n     \
      \   self.target_pts = int(target_pts)\n        self.publish_period = 1.0 / float(publish_hz)\n\
      \n        self.ctx = zmq.Context.instance()\n        self.pub = self.ctx.socket(zmq.PUB)\n\
      \        self.pub.bind(self.zmq_addr)\n\n        self.buf = np.zeros(0, dtype=np.float32)\n\
      \        self.last_pub = 0.0\n\n    def work(self, input_items, output_items):\n\
      \        x = input_items[0]\n        if x.size == 0:\n            return 0\n\
      \n        # accumulate\n        self.buf = np.concatenate([self.buf, x.astype(np.float32,\
      \ copy=False)])\n\n        now = time.time()\n        if (now - self.last_pub)\
      \ >= self.publish_period:\n            # on veut envoyer ~target_pts points,\
      \ d\xE9cim\xE9s depuis le buffer r\xE9cent\n            # on prend une fen\xEA\
      tre assez grande (ex: dernier 0.2 s si possible)\n            # et on sous-\xE9\
      chantillonne pour tomber sur target_pts\n            n = self.buf.size\n   \
      \         if n > 0:\n                # garde seulement les derniers \xE9chantillons\
      \ (limite m\xE9moire)\n                max_keep = 44100  # 1 s @ 44.1k (tu peux\
      \ ajuster)\n                if n > max_keep:\n                    self.buf =\
      \ self.buf[-max_keep:]\n                    n = self.buf.size\n\n          \
      \      # sous-\xE9chantillonnage simple\n                if n >= self.target_pts:\n\
      \                    step = max(1, n // self.target_pts)\n                 \
      \   y = self.buf[::step][:self.target_pts]\n                else:\n        \
      \            y = self.buf  # pas assez, envoie ce qu\u2019on a\n\n         \
      \       # petite normalisation d\u2019affichage (pas obligatoire)\n        \
      \        peak = float(np.max(np.abs(y))) if y.size else 0.0\n              \
      \  rms = float(np.sqrt(np.mean(y*y))) if y.size else 0.0\n\n               \
      \ msg = {\n                    \"t\": now,\n                    \"sr\": 44100,\
      \              # info indicative\n                    \"peak\": peak,\n    \
      \                \"rms\": rms,\n                    \"y\": y.tolist()\n    \
      \            }\n                try:\n                    self.pub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                except Exception:\n                  \
      \  pass\n\n                self.last_pub = now\n\n        return len(x)\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    publish_hz: '5'
    target_pts: '400'
    zmq_addr: '"tcp://127.0.0.1:5557"'
  states:
    _io_cache: ('audio_scope_zmq', 'blk', [('zmq_addr', "'tcp://127.0.0.1:5557'"),
      ('target_pts', '1200'), ('publish_hz', '20')], [('0', 'float', 1)], [], '',
      ['target_pts', 'zmq_addr'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [848, 0.0]
    rotation: 0
    state: enabled
- name: epy_block_2
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport time, json\n\
      import zmq\n\nclass blk(gr.sync_block):\n    def __init__(self, zmq_addr=\"\
      tcp://127.0.0.1:5558\",\n                 in_rate=1058400.0, target_pts=1400,\
      \ publish_hz=15,\n                 window_ms=6.0):\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"rds_scope_zmq\",\n            in_sig=[np.float32],\n\
      \            out_sig=[]\n        )\n        self.zmq_addr = zmq_addr\n     \
      \   self.in_rate = float(in_rate)\n        self.target_pts = int(target_pts)\n\
      \        self.publish_period = 1.0 / float(publish_hz)\n        self.window_ms\
      \ = float(window_ms)\n\n        self.ctx = zmq.Context.instance()\n        self.pub\
      \ = self.ctx.socket(zmq.PUB)\n        self.pub.bind(self.zmq_addr)\n\n     \
      \   self.buf = np.zeros(0, dtype=np.float32)\n        self.last_pub = 0.0\n\n\
      \        # buffer de s\xE9curit\xE9 (on garde large)\n        self.max_keep\
      \ = int(self.in_rate * 0.10)  # 100 ms\n\n    def work(self, input_items, output_items):\n\
      \        x = input_items[0]\n        if x.size == 0:\n            return 0\n\
      \n        # accumulate\n        self.buf = np.concatenate([self.buf, x.astype(np.float32,\
      \ copy=False)])\n        if self.buf.size > self.max_keep:\n            self.buf\
      \ = self.buf[-self.max_keep:]\n\n        now = time.time()\n        if (now\
      \ - self.last_pub) >= self.publish_period:\n            n = self.buf.size\n\
      \            if n > 16:\n                # ---- fen\xEAtre TEMPS impos\xE9e\
      \ ----\n                win_n = int(self.in_rate * (self.window_ms / 1000.0))\n\
      \                win_n = max(32, min(win_n, n))  # bornes\n                w\
      \ = self.buf[-win_n:]          # segment contigu\n\n                # ---- d\xE9\
      cimation d'affichage dans la fen\xEAtre ----\n                step = max(1,\
      \ win_n // self.target_pts)\n                y = w[::step][:self.target_pts]\n\
      \n                peak = float(np.max(np.abs(y))) if y.size else 0.0\n     \
      \           rms = float(np.sqrt(np.mean(y*y))) if y.size else 0.0\n\n      \
      \          msg = {\n                    \"t\": now,\n                    \"\
      sr\": self.in_rate / step,   # \"sr affich\xE9\" coh\xE9rent\n             \
      \       \"peak\": peak,\n                    \"rms\": rms,\n               \
      \     \"y\": y.tolist(),\n                    \"window_ms\": self.window_ms\n\
      \                }\n                try:\n                    self.pub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                except Exception:\n                  \
      \  pass\n\n                self.last_pub = now\n\n        return len(x)\n"
    affinity: ''
    alias: ''
    comment: ''
    in_rate: samp_rate/2/40
    maxoutbuf: '0'
    minoutbuf: '0'
    publish_hz: '5'
    target_pts: '400'
    window_ms: '12'
    zmq_addr: '"tcp://127.0.0.1:5558"'
  states:
    _io_cache: ('rds_scope_zmq', 'blk', [('zmq_addr', "'tcp://127.0.0.1:5558'"), ('in_rate',
      '1058400.0'), ('target_pts', '1400'), ('publish_hz', '15'), ('window_ms', '6.0')],
      [('0', 'float', 1)], [], '', ['in_rate', 'target_pts', 'window_ms', 'zmq_addr'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [1152, 560.0]
    rotation: 180
    state: enabled
- name: epy_block_3
  id: epy_block
  parameters:
    _source_code: "import numpy as np\nfrom gnuradio import gr\nimport time, json\n\
      import zmq\n\nclass blk(gr.sync_block):\n    \"\"\"\n    Constellation scope\
      \ web : publie un nuage I/Q (complex64) via ZMQ JSON.\n    Entr\xE9e : complex64\n\
      \    Sortie : aucune\n    \"\"\"\n    def __init__(self,\n                 zmq_addr=\"\
      tcp://127.0.0.1:5559\",\n                 points=1200,\n                 publish_hz=10,\n\
      \                 decim=1):\n        gr.sync_block.__init__(\n            self,\n\
      \            name=\"constellation_scope_zmq\",\n            in_sig=[np.complex64],\n\
      \            out_sig=[]\n        )\n        self.zmq_addr = zmq_addr\n     \
      \   self.points = int(points)\n        self.publish_period = 1.0 / float(publish_hz)\n\
      \        self.decim = max(1, int(decim))\n\n        self.ctx = zmq.Context.instance()\n\
      \        self.pub = self.ctx.socket(zmq.PUB)\n        self.pub.bind(self.zmq_addr)\n\
      \n        self.buf = np.zeros(0, dtype=np.complex64)\n        self.last_pub\
      \ = 0.0\n        self.max_keep = self.points * self.decim * 4  # marge\n\n \
      \   def work(self, input_items, output_items):\n        x = input_items[0]\n\
      \        if x.size == 0:\n            return 0\n\n        # d\xE9cimation l\xE9\
      g\xE8re pour limiter la charge\n        if self.decim > 1:\n            x =\
      \ x[::self.decim]\n\n        self.buf = np.concatenate([self.buf, x.astype(np.complex64,\
      \ copy=False)])\n        if self.buf.size > self.max_keep:\n            self.buf\
      \ = self.buf[-self.max_keep:]\n\n        now = time.time()\n        if (now\
      \ - self.last_pub) >= self.publish_period:\n            n = self.buf.size\n\
      \            if n >= 16:\n                N = min(self.points, n)\n        \
      \        z = self.buf[-N:]\n\n                i = np.real(z).astype(np.float32)\n\
      \                q = np.imag(z).astype(np.float32)\n\n                msg =\
      \ {\n                    \"t\": now,\n                    \"n\": int(N),\n \
      \                   \"i\": i.tolist(),\n                    \"q\": q.tolist()\n\
      \                }\n                try:\n                    self.pub.send_string(json.dumps(msg),\
      \ flags=zmq.NOBLOCK)\n                except Exception:\n                  \
      \  pass\n\n                self.last_pub = now\n\n        return len(input_items[0])\n"
    affinity: ''
    alias: ''
    comment: ''
    decim: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    points: '600'
    publish_hz: '5'
    zmq_addr: '"tcp://127.0.0.1:5559"'
  states:
    _io_cache: "('constellation_scope_zmq', 'blk', [('zmq_addr', \"'tcp://127.0.0.1:5559'\"\
      ), ('points', '1200'), ('publish_hz', '10'), ('decim', '1')], [('0', 'complex',\
      \ 1)], [], '\\nConstellation scope web : publie un nuage I/Q (complex64) via\
      \ ZMQ JSON.\\nEntr\xE9e : complex64\\nSortie : aucune\\n', ['decim', 'points',\
      \ 'zmq_addr'])"
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [840, 464.0]
    rotation: 180
    state: enabled
- name: epy_block_6
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport numpy\
      \ as np\nfrom gnuradio import gr\nimport pmt\nfrom collections import deque\n\
      \n\nclass RDS_correlate_access_code_tag(gr.sync_block):\n    \"\"\"\n    correlator\
      \ with dynamic access code for RDS stream.\n\n    - Input: stream of 0/1 bits\
      \ (uint8)\n    - Code provided via message (\"0101...\")\n    - Detection using\
      \ a sliding window\n    - A tag is placed just after the last bit of the detected\
      \ pattern\n    - Both the code and its inverse are detected (phase inversion)\n\
      \n    \"\"\"\n\n    def __init__(self, tag_name=\"packet\"):\n        gr.sync_block.__init__(\n\
      \            self,\n            name=\"RDS_correlate_access_code_tag\",\n  \
      \          in_sig=[np.uint8],\n            out_sig=[np.uint8]\n        )\n\n\
      \        self.tag_key = pmt.intern(tag_name)\n\n        # Message input port\
      \ to receive the access code\n        self.port_in = pmt.intern(\"set_code\"\
      )\n        self.message_port_register_in(self.port_in)\n        self.set_msg_handler(self.port_in,\
      \ self._set_code)\n\n        self.code = None          # access code as a list\
      \ of 0/1 bits\n        self.code_inv = None      # binary inverse of the code\n\
      \        self.shift = deque()      # shift register\n\n    def _set_code(self,\
      \ msg):\n        # Convert PMT message to Python string\n        if pmt.is_symbol(msg):\n\
      \            s = pmt.symbol_to_string(msg)\n        elif pmt.is_string(msg):\n\
      \            s = pmt.string_to_python(msg)\n        else:\n            s = pmt.write_string(msg)\n\
      \n        # Keep only '0' and '1' characters\n        code = [1 if c == \"1\"\
      \ else 0 for c in s]\n        if len(code) < 2:\n            return\n\n    \
      \    self.code = code\n        self.code_inv = [1 - b for b in code]\n     \
      \   self.shift = deque(maxlen=len(code))  # reset and set proper length\n\n\
      \    def work(self, input_items, output_items):\n        y = output_items[0]\n\
      \        y[:] = input_items[0]\n\n        n = len(y)\n        abs_out0 = int(self.nitems_written(0))\
      \  # Absolute output offset\n\n        if self.code is None:\n            return\
      \ n\n\n        code = self.code\n        inv = self.code_inv\n        L = len(code)\n\
      \n        for i in range(n):\n            # Update the sliding window\n    \
      \        self.shift.append(int(y[i]))\n\n            # Check for exact match\
      \ with code or its inverse\n            if len(self.shift) == L:\n         \
      \       w = list(self.shift)\n                if w == code or w == inv:\n  \
      \                  # Tag position: just after the last bit of the pattern\n\
      \                    t = abs_out0 + i + 1\n                    self.add_item_tag(0,\
      \ t, self.tag_key, pmt.from_long(0))\n\n        return n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    tag_name: '''packet'''
  states:
    _io_cache: '(''RDS_correlate_access_code_tag'', ''RDS_correlate_access_code_tag'',
      [(''tag_name'', "''packet''")], [(''0'', ''byte'', 1), (''set_code'', ''message'',
      1)], [(''0'', ''byte'', 1)], ''\ncorrelator with dynamic access code for RDS
      stream.\n\n- Input: stream of 0/1 bits (uint8)\n- Code provided via message
      ("0101...")\n- Detection using a sliding window\n- A tag is placed just after
      the last bit of the detected pattern\n- Both the code and its inverse are detected
      (phase inversion)\n\n'', [])'
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [488, 600.0]
    rotation: 0
    state: enabled
- name: epy_block_8
  id: epy_block
  parameters:
    _source_code: "#!/usr/bin/env python3\n# -*- coding: utf-8 -*-\n\nimport numpy\
      \ as np\nfrom gnuradio import gr\nimport pmt\n\n\nclass rds_motif_learner(gr.sync_block):\n\
      \    \"\"\"\n    RDS motif learner based on simple statistical counting.\n\n\
      \    - Keeps a FIFO to preserve continuity across GNU Radio buffers\n    - Periodically\
      \ scans a sliding window of bits\n    - Extracts all 32-bit blocks from this\
      \ window\n    - Keeps only blocks starting with the RDS prefix (or its inverse)\n\
      \    - Selects the most frequent block and publishes it as a message\n    \"\
      \"\"\n\n    def __init__(self,\n                 window_bits=2500,\n       \
      \          verbose=False):\n\n        gr.sync_block.__init__(\n            self,\n\
      \            name=\"rds_motif_learner\",\n            in_sig=[np.uint8],\n \
      \           out_sig=[np.uint8]\n        )\n\n        # --- RDS fixed parameters\
      \ ---\n        self.P = 208                # RDS group length (samples)  -->\
      \ 104 bits\n        self.L = 32                 # RDS checkword length (samples)\
      \ --> 16 bits (e.g F201, F405...etc.)\n\n        self.window = int(window_bits)\n\
      \        self.verbose = bool(verbose)\n\n        # Fixed RDS prefix (normal\
      \ + inverted)\n        self.prefix = (0, 1, 1, 0, 0, 1, 1, 0, 1)\n        self.plen\
      \ = len(self.prefix)\n        self.prefix_inv = tuple(1 - b for b in self.prefix)\n\
      \n        # Prefixes converted as integers for fast comparison in work()\n \
      \       self.prefix_int = int(\"\".join(str(b) for b in self.prefix), 2)\n \
      \       self.prefix_inv_int = int(\"\".join(str(b) for b in self.prefix_inv),\
      \ 2)\n\n        # Mask to keep exactly 32 bits when packing\n        self.mask\
      \ = (1 << self.L) - 1\n\n        # Message output port: send detected code (\"\
      0101...\")\n        self.port_out = pmt.intern(\"code\")\n        self.message_port_register_out(self.port_out)\n\
      \n        # Internal state\n        self.fifo = []              # bit history\n\
      \        self.since_scan = 0         # counter since last scan\n        self.last_sent\
      \ = None       # last emitted motif (anti-spam)\n\n        # Maximum FIFO size\
      \ (window + margin + motif)\n        self.keep = self.window + 5*self.P + self.L\n\
      \n    def _emit_int(self, code_int, score):\n        \"\"\"\n        Convert\
      \ an integer motif to a 32-bit binary string\n        and publish it on the\
      \ message port.\n        \"\"\"\n        bits = format(code_int, \"032b\")\n\
      \        self.message_port_pub(self.port_out, pmt.intern(bits))\n        self.last_sent\
      \ = code_int\n        if self.verbose:\n            print(f\"[learner] best={bits}\
      \ score={score}\")\n\n    def work(self, input_items, output_items):\n     \
      \   # Pass-through of the input bitstream\n        y = output_items[0]\n   \
      \     y[:] = input_items[0]\n        n = len(y)\n\n        # Push new bits into\
      \ the FIFO\n        self.fifo.extend(int(b) for b in y)\n        if len(self.fifo)\
      \ > self.keep:\n            self.fifo = self.fifo[-self.keep:]\n\n        #\
      \ Scan only every window_bits\n        self.since_scan += n\n        if self.since_scan\
      \ < self.window:\n            return n\n        self.since_scan = 0\n\n    \
      \    fifo = self.fifo\n\n        # Not enough data\n        if len(fifo) < self.L:\n\
      \            return n\n\n        # Maximum number of motifs to test in the window\n\
      \        scan_max = min(len(fifo) - self.L + 1, self.window)\n        if scan_max\
      \ <= 0:\n            return n\n\n        # Rolling 32-bit packing into integers\n\
      \        code_int = 0\n        for i in range(self.L):\n            code_int\
      \ = ((code_int << 1) | fifo[i]) & self.mask\n\n        codes = [0] * scan_max\n\
      \        codes[0] = code_int\n        for s in range(1, scan_max):\n       \
      \     code_int = ((code_int << 1) & self.mask) | fifo[s + self.L - 1]\n    \
      \        codes[s] = code_int\n\n        # Count occurrences with prefix filtering\n\
      \        scores = {}\n        shift_prefix = self.L - self.plen\n\n        for\
      \ a in codes:\n            head = a >> shift_prefix\n            if head !=\
      \ self.prefix_int and head != self.prefix_inv_int:\n                continue\n\
      \            scores[a] = scores.get(a, 0) + 1\n\n        if not scores:\n  \
      \          return n\n\n        # Select the most frequent motif\n        best\
      \ = max(scores, key=scores.get)\n\n        # Emit only if it changed\n     \
      \   if best != self.last_sent:\n            self._emit_int(best, scores[best])\n\
      \n        return n\n"
    affinity: ''
    alias: ''
    comment: ''
    maxoutbuf: '0'
    minoutbuf: '0'
    verbose: 'False'
    window_bits: '3000'
  states:
    _io_cache: ('rds_motif_learner', 'rds_motif_learner', [('window_bits', '2500'),
      ('verbose', 'False')], [('0', 'byte', 1)], [('0', 'byte', 1), ('code', 'message',
      1)], '\nRDS motif learner based on simple statistical counting.\n\n- Keeps a
      FIFO to preserve continuity across GNU Radio buffers\n- Periodically scans a
      sliding window of bits\n- Extracts all 32-bit blocks from this window\n- Keeps
      only blocks starting with the RDS prefix (or its inverse)\n- Selects the most
      frequent block and publishes it as a message\n', ['verbose'])
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [256, 600.0]
    rotation: 0
    state: enabled
- name: freq_xlating_fir_filter_xxx_0
  id: freq_xlating_fir_filter_xxx
  parameters:
    affinity: ''
    alias: ''
    center_freq: '57000'
    comment: ''
    decim: '20'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate/4
    taps: firdes.low_pass(1,samp_rate/4,3000,500,window.WIN_HAMMING)
    type: fcc
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [640, 200.0]
    rotation: 0
    state: enabled
- name: low_pass_filter_0_1
  id: low_pass_filter
  parameters:
    affinity: ''
    alias: ''
    beta: '6.76'
    comment: ''
    cutoff_freq: 20e3
    decim: '12'
    gain: '1'
    interp: '1'
    maxoutbuf: '0'
    minoutbuf: '0'
    samp_rate: samp_rate/4
    type: fir_filter_fff
    width: 10e3
    win: window.WIN_HAMMING
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [608, 16.0]
    rotation: 0
    state: enabled
- name: rtlsdr_source_0
  id: rtlsdr_source
  parameters:
    affinity: ''
    alias: ''
    ant0: ''
    ant1: ''
    ant10: ''
    ant11: ''
    ant12: ''
    ant13: ''
    ant14: ''
    ant15: ''
    ant16: ''
    ant17: ''
    ant18: ''
    ant19: ''
    ant2: ''
    ant20: ''
    ant21: ''
    ant22: ''
    ant23: ''
    ant24: ''
    ant25: ''
    ant26: ''
    ant27: ''
    ant28: ''
    ant29: ''
    ant3: ''
    ant30: ''
    ant31: ''
    ant4: ''
    ant5: ''
    ant6: ''
    ant7: ''
    ant8: ''
    ant9: ''
    args: '""'
    bb_gain0: gain
    bb_gain1: '20'
    bb_gain10: '20'
    bb_gain11: '20'
    bb_gain12: '20'
    bb_gain13: '20'
    bb_gain14: '20'
    bb_gain15: '20'
    bb_gain16: '20'
    bb_gain17: '20'
    bb_gain18: '20'
    bb_gain19: '20'
    bb_gain2: '20'
    bb_gain20: '20'
    bb_gain21: '20'
    bb_gain22: '20'
    bb_gain23: '20'
    bb_gain24: '20'
    bb_gain25: '20'
    bb_gain26: '20'
    bb_gain27: '20'
    bb_gain28: '20'
    bb_gain29: '20'
    bb_gain3: '20'
    bb_gain30: '20'
    bb_gain31: '20'
    bb_gain4: '20'
    bb_gain5: '20'
    bb_gain6: '20'
    bb_gain7: '20'
    bb_gain8: '20'
    bb_gain9: '20'
    bw0: '0'
    bw1: '0'
    bw10: '0'
    bw11: '0'
    bw12: '0'
    bw13: '0'
    bw14: '0'
    bw15: '0'
    bw16: '0'
    bw17: '0'
    bw18: '0'
    bw19: '0'
    bw2: '0'
    bw20: '0'
    bw21: '0'
    bw22: '0'
    bw23: '0'
    bw24: '0'
    bw25: '0'
    bw26: '0'
    bw27: '0'
    bw28: '0'
    bw29: '0'
    bw3: '0'
    bw30: '0'
    bw31: '0'
    bw4: '0'
    bw5: '0'
    bw6: '0'
    bw7: '0'
    bw8: '0'
    bw9: '0'
    clock_source0: ''
    clock_source1: ''
    clock_source2: ''
    clock_source3: ''
    clock_source4: ''
    clock_source5: ''
    clock_source6: ''
    clock_source7: ''
    comment: ''
    corr0: '0'
    corr1: '0'
    corr10: '0'
    corr11: '0'
    corr12: '0'
    corr13: '0'
    corr14: '0'
    corr15: '0'
    corr16: '0'
    corr17: '0'
    corr18: '0'
    corr19: '0'
    corr2: '0'
    corr20: '0'
    corr21: '0'
    corr22: '0'
    corr23: '0'
    corr24: '0'
    corr25: '0'
    corr26: '0'
    corr27: '0'
    corr28: '0'
    corr29: '0'
    corr3: '0'
    corr30: '0'
    corr31: '0'
    corr4: '0'
    corr5: '0'
    corr6: '0'
    corr7: '0'
    corr8: '0'
    corr9: '0'
    dc_offset_mode0: '0'
    dc_offset_mode1: '0'
    dc_offset_mode10: '0'
    dc_offset_mode11: '0'
    dc_offset_mode12: '0'
    dc_offset_mode13: '0'
    dc_offset_mode14: '0'
    dc_offset_mode15: '0'
    dc_offset_mode16: '0'
    dc_offset_mode17: '0'
    dc_offset_mode18: '0'
    dc_offset_mode19: '0'
    dc_offset_mode2: '0'
    dc_offset_mode20: '0'
    dc_offset_mode21: '0'
    dc_offset_mode22: '0'
    dc_offset_mode23: '0'
    dc_offset_mode24: '0'
    dc_offset_mode25: '0'
    dc_offset_mode26: '0'
    dc_offset_mode27: '0'
    dc_offset_mode28: '0'
    dc_offset_mode29: '0'
    dc_offset_mode3: '0'
    dc_offset_mode30: '0'
    dc_offset_mode31: '0'
    dc_offset_mode4: '0'
    dc_offset_mode5: '0'
    dc_offset_mode6: '0'
    dc_offset_mode7: '0'
    dc_offset_mode8: '0'
    dc_offset_mode9: '0'
    freq0: freq*1e6
    freq1: 100e6
    freq10: 100e6
    freq11: 100e6
    freq12: 100e6
    freq13: 100e6
    freq14: 100e6
    freq15: 100e6
    freq16: 100e6
    freq17: 100e6
    freq18: 100e6
    freq19: 100e6
    freq2: 100e6
    freq20: 100e6
    freq21: 100e6
    freq22: 100e6
    freq23: 100e6
    freq24: 100e6
    freq25: 100e6
    freq26: 100e6
    freq27: 100e6
    freq28: 100e6
    freq29: 100e6
    freq3: 100e6
    freq30: 100e6
    freq31: 100e6
    freq4: 100e6
    freq5: 100e6
    freq6: 100e6
    freq7: 100e6
    freq8: 100e6
    freq9: 100e6
    gain0: gain
    gain1: '10'
    gain10: '10'
    gain11: '10'
    gain12: '10'
    gain13: '10'
    gain14: '10'
    gain15: '10'
    gain16: '10'
    gain17: '10'
    gain18: '10'
    gain19: '10'
    gain2: '10'
    gain20: '10'
    gain21: '10'
    gain22: '10'
    gain23: '10'
    gain24: '10'
    gain25: '10'
    gain26: '10'
    gain27: '10'
    gain28: '10'
    gain29: '10'
    gain3: '10'
    gain30: '10'
    gain31: '10'
    gain4: '10'
    gain5: '10'
    gain6: '10'
    gain7: '10'
    gain8: '10'
    gain9: '10'
    gain_mode0: 'False'
    gain_mode1: 'False'
    gain_mode10: 'False'
    gain_mode11: 'False'
    gain_mode12: 'False'
    gain_mode13: 'False'
    gain_mode14: 'False'
    gain_mode15: 'False'
    gain_mode16: 'False'
    gain_mode17: 'False'
    gain_mode18: 'False'
    gain_mode19: 'False'
    gain_mode2: 'False'
    gain_mode20: 'False'
    gain_mode21: 'False'
    gain_mode22: 'False'
    gain_mode23: 'False'
    gain_mode24: 'False'
    gain_mode25: 'False'
    gain_mode26: 'False'
    gain_mode27: 'False'
    gain_mode28: 'False'
    gain_mode29: 'False'
    gain_mode3: 'False'
    gain_mode30: 'False'
    gain_mode31: 'False'
    gain_mode4: 'False'
    gain_mode5: 'False'
    gain_mode6: 'False'
    gain_mode7: 'False'
    gain_mode8: 'False'
    gain_mode9: 'False'
    if_gain0: '30'
    if_gain1: '20'
    if_gain10: '20'
    if_gain11: '20'
    if_gain12: '20'
    if_gain13: '20'
    if_gain14: '20'
    if_gain15: '20'
    if_gain16: '20'
    if_gain17: '20'
    if_gain18: '20'
    if_gain19: '20'
    if_gain2: '20'
    if_gain20: '20'
    if_gain21: '20'
    if_gain22: '20'
    if_gain23: '20'
    if_gain24: '20'
    if_gain25: '20'
    if_gain26: '20'
    if_gain27: '20'
    if_gain28: '20'
    if_gain29: '20'
    if_gain3: '20'
    if_gain30: '20'
    if_gain31: '20'
    if_gain4: '20'
    if_gain5: '20'
    if_gain6: '20'
    if_gain7: '20'
    if_gain8: '20'
    if_gain9: '20'
    iq_balance_mode0: '0'
    iq_balance_mode1: '0'
    iq_balance_mode10: '0'
    iq_balance_mode11: '0'
    iq_balance_mode12: '0'
    iq_balance_mode13: '0'
    iq_balance_mode14: '0'
    iq_balance_mode15: '0'
    iq_balance_mode16: '0'
    iq_balance_mode17: '0'
    iq_balance_mode18: '0'
    iq_balance_mode19: '0'
    iq_balance_mode2: '0'
    iq_balance_mode20: '0'
    iq_balance_mode21: '0'
    iq_balance_mode22: '0'
    iq_balance_mode23: '0'
    iq_balance_mode24: '0'
    iq_balance_mode25: '0'
    iq_balance_mode26: '0'
    iq_balance_mode27: '0'
    iq_balance_mode28: '0'
    iq_balance_mode29: '0'
    iq_balance_mode3: '0'
    iq_balance_mode30: '0'
    iq_balance_mode31: '0'
    iq_balance_mode4: '0'
    iq_balance_mode5: '0'
    iq_balance_mode6: '0'
    iq_balance_mode7: '0'
    iq_balance_mode8: '0'
    iq_balance_mode9: '0'
    maxoutbuf: '0'
    minoutbuf: '0'
    nchan: '1'
    num_mboards: '1'
    sample_rate: samp_rate
    sync: sync
    time_source0: ''
    time_source1: ''
    time_source2: ''
    time_source3: ''
    time_source4: ''
    time_source5: ''
    time_source6: ''
    time_source7: ''
    type: fc32
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [40, 92.0]
    rotation: 0
    state: enabled
- name: xmlrpc_server_0
  id: xmlrpc_server
  parameters:
    addr: 127.0.0.1
    alias: ''
    comment: ''
    port: '8080'
  states:
    bus_sink: false
    bus_source: false
    bus_structure: null
    coordinate: [296, 8.0]
    rotation: 0
    state: enabled

connections:
- [analog_agc_xx_0, '0', digital_costas_loop_cc_0, '0']
- [analog_wfm_rcv_0_0, '0', freq_xlating_fir_filter_xxx_0, '0']
- [analog_wfm_rcv_0_0, '0', low_pass_filter_0_1, '0']
- [blocks_complex_to_arg_0_0_0, '0', blocks_threshold_ff_0, '0']
- [blocks_complex_to_real_0, '0', epy_block_2, '0']
- [blocks_float_to_uchar_0, '0', epy_block_8, '0']
- [blocks_threshold_ff_0, '0', blocks_float_to_uchar_0, '0']
- [digital_costas_loop_cc_0, '0', blocks_complex_to_real_0, '0']
- [digital_costas_loop_cc_0, '0', digital_symbol_sync_xx_0, '0']
- [digital_symbol_sync_xx_0, '0', blocks_complex_to_arg_0_0_0, '0']
- [digital_symbol_sync_xx_0, '0', epy_block_3, '0']
- [epy_block_6, '0', epy_block_0, '0']
- [epy_block_8, '0', epy_block_6, '0']
- [epy_block_8, code, epy_block_6, set_code]
- [freq_xlating_fir_filter_xxx_0, '0', analog_agc_xx_0, '0']
- [low_pass_filter_0_1, '0', audio_sink_0, '0']
- [low_pass_filter_0_1, '0', epy_block_1, '0']
- [rtlsdr_source_0, '0', analog_wfm_rcv_0_0, '0']

metadata:
  file_format: 1
  grc_version: 3.10.12.0
